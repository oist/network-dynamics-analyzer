
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Helper functions &#8212; IDTxl 1.0 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="idtxl package" href="idtxl.html" />
    <link rel="prev" title="Information theoretic estimators" href="idtxl_estimators.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl.html" title="idtxl package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="idtxl_estimators.html" title="Information theoretic estimators"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="helper-functions">
<h1>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="utils-module">
<h2>utils module<a class="headerlink" href="#utils-module" title="Permalink to this headline">¶</a></h2>
<p>Provide IDTxl utility functions.</p>
<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">argsort_descending</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#argsort_descending"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Sort array in descending order and return sortind indices.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">autocorrelation</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#autocorrelation"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculate autocorrelation of a vector.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">calculate_mi</code><span class="sig-paren">(</span><em>corr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#calculate_mi"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Calculate mutual information from correlation coefficient.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">combine_discrete_dimensions</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_discrete_dimensions"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Combine multi-dimensional discrete variable into a single dimension.</p>
<p>Combine all dimensions for a discrete variable down into a single
dimensional value for each sample. This is done basically by multiplying
each dimension by a different power of the base (numBins).</p>
<p>Adapted from infodynamics.utils.MatrixUtils.computeCombinedValues() from
JIDT by J.Lizier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be combined across all variable dimensions. Dimensions are
realisations (samples) x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins for each variable dimension</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>a univariate array – one entry now for each sample,
with all dimensions of the data now combined for that sample</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">conflicting_entries</code><span class="sig-paren">(</span><em>dict_1</em>, <em>dict_2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#conflicting_entries"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Test two dictionaries for unequal entries.</p>
<p>Note that only keys that are present in both dicts are compared. If one
dictionary contains an entry not present in the other dictionary, the
test passes.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">discretise</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Discretise continuous data.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
evenly partitioning the range of the data, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretise() from JIDT by
J. Lizier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">discretise_max_ent</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise_max_ent"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Discretise continuous data using maximum entropy partitioning.</p>
<p>Discretise continuous data into discrete values (with 0 as lowest) by
making a maximum entropy partitioning, one dimension at a time. Adapted
from infodynamics.utils.MatrixUtils.discretiseMaxEntropy() from JIDT by
J. Lizier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">equal_dicts</code><span class="sig-paren">(</span><em>dict_1</em>, <em>dict_2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#equal_dicts"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Test two dictionaries for equality.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">print_dict</code><span class="sig-paren">(</span><em>d</em>, <em>indent=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#print_dict"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Use Python’s pretty printer to print dictionaries to the console.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">remove_column</code><span class="sig-paren">(</span><em>a</em>, <em>j</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_column"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove a column from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>column index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">remove_row</code><span class="sig-paren">(</span><em>a</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_row"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove a row from a numpy array.</p>
<p>This is faster than logical indexing (‘25 times faster’), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>row index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">separate_arrays</code><span class="sig-paren">(</span><em>idx_all</em>, <em>idx_single</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#separate_arrays"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Separate a single column from all other columns in a 2D-array.</p>
<p>Return the separated single column and the remaining columns of a 2D-
array.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>idx_all <span class="classifier-delimiter">:</span> <span class="classifier">list&lt;Object&gt;</span></dt>
<dd>list of variables indicating the full set</dd>
<dt>idx_single <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Object&gt;</span></dt>
<dd>single variable indicating the column to be separated, variable
must be contained in idx_all</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2D-array with the same length along axis 1 as idx_all
(.shape[1] == len(idx_all))</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>remaining columns in full array</dd>
<dt>numpy array</dt>
<dd>column at single index</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">sort_descending</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#sort_descending"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Sort array in descending order.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">standardise</code><span class="sig-paren">(</span><em>a</em>, <em>dimension=0</em>, <em>df=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#standardise"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Z-standardise a numpy array along a given dimension.</p>
<p>Standardise array along the axis defined in dimension using the denominator
(N - df) for the calculation of the standard deviation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be standardised</dd>
<dt>dimension <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>dimension along which array should be standardised</dd>
<dt>df <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>degrees of freedom for the denominator of the standard derivation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>standardised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">swap_chars</code><span class="sig-paren">(</span><em>s</em>, <em>i_1</em>, <em>i_2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#swap_chars"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Swap to characters in a string.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">swap_chars</span><span class="p">(</span><span class="s1">&#39;heLlotHere&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">&#39;heHlotLere&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="stats-module">
<h2>stats module<a class="headerlink" href="#stats-module" title="Permalink to this headline">¶</a></h2>
<p>Provide statistics functions.</p>
<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">ais_fdr</code><span class="sig-paren">(</span><em>settings=None</em>, <em>*results</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#ais_fdr"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform FDR-correction on results of network AIS estimation.</p>
<p>Perform correction of the false discovery rate (FDR) after estimation of
active information storage (AIS) for all processes in the network. FDR
correction is applied by correcting the AIS estimate’s omnibus p-values for
individual processes/nodes in the network.</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</li>
</ul>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing with entries:</p>
<ul class="last simple">
<li>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</li>
<li>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</li>
</ul>
</dd>
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">instances of ResultsSingleProcessAnalysis</span></dt>
<dd>results of network AIS estimation, see documentation of
ResultsSingleProcessAnalysis()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ResultsSingleProcessAnalysis instance</dt>
<dd>input results objects pruned of non-significant estimates</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">check_n_perm</code><span class="sig-paren">(</span><em>n_perm</em>, <em>alpha</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#check_n_perm"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Check if no. permutations is big enough to obtain the requested alpha.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>The no. permutations must be big enough to theoretically allow for the
detection of a p-value that is smaller than the critical alpha level.
Otherwise the permutation test is pointless. The smalles possible
p-value is 1/n_perm.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">max_statistic</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_max_candidate</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform maximum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the maximum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_max_stat : int [optional] - number of permutations
(default=200)</li>
<li>alpha_max_stat : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_max_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension] (per default all
already selected source and target variables from the
analysis_setup are used)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test’s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ex.AlgorithmExhaustedError</dt>
<dd>Raised from _create_surrogate_table() when calculation cannot be made</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">max_statistic_sequential</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id1"><span class="problematic" id="id2">|</span></a>500)</li>
<li>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array, bool</dt>
<dd>statistical significance of each source</dd>
<dt>numpy array, float</dt>
<dd>the test’s p-values for each source</dd>
<dt>numpy array, float</dt>
<dd>TE values for individual sources</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">max_statistic_sequential_bivariate</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential_bivariate"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test multivariate/bivariate MI/TE values against surrogates. Test highest
TE/MI value against distribution of highest surrogate values, second
highest against distribution of second highest, and so forth. Surrogates
are created from each candidate in the candidate set, including the
candidate that is currently tested. Surrogates are then sorted over
candidates. This is repeated n_perm_max_seq times. Stop comparison if a
TE/MI value is not significant compared to the distribution of surrogate
values of the same rank. All smaller values are considered non-significant
as well.</p>
<p>The conditional for estimation of MI/TE is taken from the current set of
conditional variables in the analysis setup. For multivariate MI or TE
surrogate creation, the full set of conditional variables is used. For
bivariate MI or TE surrogate creation, the conditioning set has to be
restricted to a subset of the current set of conditional variables: for
bivariate MI no conditioning set is required, for bivariate TE only the
past variables from the target are required (not the variables selected
from other relevant sources).</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<p>Args:</p>
<blockquote>
<div><dl class="docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_max_seq : int [optional] - number of permutations
(default=’n_perm_min_stat’<a href="#id3"><span class="problematic" id="id4">|</span></a>500)</li>
<li>alpha_max_seq : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array, bool</dt>
<dd>statistical significance of each source</dd>
<dt>numpy array, float</dt>
<dd>the test’s p-values for each source</dd>
<dt>numpy array, float</dt>
<dd>TE values for individual sources</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">mi_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#mi_against_surrogates"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Test estimated mutual information for significance against surrogate data.</p>
<p>Shuffle realisations of the current value (point to be predicted) and re-
calculate mutual information (MI) for shuffled data. The actual estimated
MI is then compared against this distribution of MI values from surrogate
data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_mi : int [optional] - number of permutations
(default=500)</li>
<li>alpha_mi : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>estimated MI value</dd>
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>p_value for estimated MI value</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ex.AlgorithmExhaustedError</dt>
<dd>Raised from estimate() methods when calculation cannot be made</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">min_statistic</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_min_candidate</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#min_statistic"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform minimum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the minimum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_min_stat : int [optional] - number of permutations
(default=500)</li>
<li>alpha_min_stat : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_min_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of conditional, 2D numpy array where array dimensions
represent [realisations x variable dimension] (per default all
already selected source and target variables from the
analysis_setup are used)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test’s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ex.AlgorithmExhaustedError</dt>
<dd>Raised from _create_surrogate_table() when calculation cannot be made</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">network_fdr</code><span class="sig-paren">(</span><em>settings=None</em>, <em>*results</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#network_fdr"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform FDR-correction on results of network inference.</p>
<p>Perform correction of the false discovery rate (FDR) after network
analysis. FDR correction can either be applied at the target level
(by correcting omnibus p-values) or at the single-link level (by correcting
p-values of individual links between single samples and the target).</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<ul class="simple">
<li>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</li>
</ul>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing with entries:</p>
<ul class="last simple">
<li>alpha_fdr : float [optional] - critical alpha level
(default=0.05)</li>
<li>correct_by_target : bool [optional] - if true correct p-values on
on the target level (omnibus test p-values), otherwise correct
p_values for individual variables (sequential max stats p-values)
(default=True)</li>
<li>fdr_constant : int [optional] - choose one of two constants used
for calculating the FDR-thresholds according to Genovese (2002):
1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);
see the paper for details on the assumptions (default=2)</li>
</ul>
</dd>
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">instances of ResultsNetworkInference</span></dt>
<dd>results of network inference, see documentation of
ResultsNetworkInference()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ResultsNetworkInference instance</dt>
<dd>input object pruned of non-significant links</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">omnibus_test</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#omnibus_test"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Perform an omnibus test on identified conditional variables.</p>
<p>Test the joint information transfer from all identified sources to the
current value conditional on candidates in the target’s past. To test for
significance, this is repeated for shuffled realisations of the sources.
The distribution of values from shuffled data is then used as test
distribution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
‘settings’, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>n_perm_omnibus : int [optional] - number of permutations
(default=500)</li>
<li>alpha_omnibus : float [optional] - critical alpha level
(default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test’s p-value</dd>
<dt>float</dt>
<dd>the estimated test statisic, i.e., the information transfer from
all sources into the target</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>ex.AlgorithmExhaustedError</dt>
<dd>Raised from estimate() calls when calculation cannot be made</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">syn_shd_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#syn_shd_against_surrogates"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Test the shared/synergistic information in the PID estimate.</p>
<p>Shuffle realisations of the target and re-calculate PID, in particular the
synergistic and shared information from shuffled data. The original
shared and synergistic information are then compared against the
distribution of values calculated from surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Partial_information_decomposition instance</span></dt>
<dd><p class="first">information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="last simple">
<li>n_perm : int [optional] - number of permutations (default=500)</li>
<li>alpha : float [optional] - critical alpha level (default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>PID estimate from original data</dd>
<dt>bool</dt>
<dd>statistical significance of the shared information</dd>
<dt>float</dt>
<dd>p-value of the shared information</dd>
<dt>bool</dt>
<dd>statistical significance of the synergistic information</dd>
<dt>float</dt>
<dd>p-value of the synergistic information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt>
<code class="descclassname">idtxl.stats.</code><code class="descname">unq_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#unq_against_surrogates"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Test the unique information in the PID estimate against surrogate data.</p>
<p>Shuffle realisations of both sources individually and re-calculate PID,
in particular the unique information from shuffled data. The original
unique information is then compared against the distribution of values
calculated from surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Partial_information_decomposition instance</span></dt>
<dd><p class="first">information on the current analysis, should have an Attribute
‘settings’, a dict with optional fields</p>
<ul class="last simple">
<li>n_perm : int [optional] - number of permutations (default=500)</li>
<li>alpha : float [optional] - critical alpha level (default=0.05)</li>
<li>permute_in_time : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>PID estimate from original data</dd>
<dt>bool</dt>
<dd>statistical significance of the unique information in source 1</dd>
<dt>float</dt>
<dd>p-value of the unique information in source 1</dd>
<dt>bool</dt>
<dd>statistical significance of the unique information in source 2</dd>
<dt>float</dt>
<dd>p-value of the unique information in source 2</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Helper functions</a><ul>
<li><a class="reference internal" href="#utils-module">utils module</a></li>
<li><a class="reference internal" href="#stats-module">stats module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="idtxl_estimators.html"
                        title="previous chapter">Information theoretic estimators</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="idtxl.html"
                        title="next chapter">idtxl package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl_helper.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="idtxl.html" title="idtxl package"
             >next</a> |</li>
        <li class="right" >
          <a href="idtxl_estimators.html" title="Information theoretic estimators"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">IDTxl 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>