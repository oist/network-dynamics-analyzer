
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>idtxl.estimators_jidt &#8212; IDTxl 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for idtxl.estimators_jidt</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Provide JIDT estimators.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">resource_filename</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">idtxl.estimator</span> <span class="k">import</span> <span class="n">Estimator</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">idtxl_exceptions</span> <span class="k">as</span> <span class="n">ex</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">idtxl_utils</span> <span class="k">as</span> <span class="n">utils</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">jpype</span> <span class="k">as</span> <span class="nn">jp</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">ex</span><span class="o">.</span><span class="n">package_missing</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="s1">&#39;Jpype is not available on this system. Install it&#39;</span>
                            <span class="s1">&#39; from https://pypi.python.org/pypi/JPype1 to use &#39;</span>
                            <span class="s1">&#39;JAVA/JIDT-powered CMI estimation.&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="JidtEstimator"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtEstimator">[docs]</a><span class="k">class</span> <span class="nc">JidtEstimator</span><span class="p">(</span><span class="n">Estimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for implementation of JIDT estimators.</span>

<span class="sd">    Abstract class for implementation of JIDT estimators, child classes</span>
<span class="sd">    implement estimators for mutual information (MI), conditional mutual</span>
<span class="sd">    information (CMI), active information storage (AIS), transfer entropy (TE)</span>
<span class="sd">    using the Kraskov-Grassberger-Stoegbauer estimator for continuous data,</span>
<span class="sd">    plug-in estimators for discrete data, and Gaussian estimators for</span>
<span class="sd">    continuous Gaussian data.</span>

<span class="sd">    References:</span>

<span class="sd">    - Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for</span>
<span class="sd">      studying the dynamics of complex systems. Front Robot AI, 1(11).</span>
<span class="sd">    - Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual</span>
<span class="sd">      information. Phys Rev E, 69(6), 066138.</span>
<span class="sd">    - Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).</span>
<span class="sd">      Local measures of information storage in complex distributed computation.</span>
<span class="sd">      Inform Sci, 208, 39-54.</span>
<span class="sd">    - Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,</span>
<span class="sd">      85(2), 461.</span>

<span class="sd">    Set common estimation parameters for JIDT estimators. For usage of these</span>
<span class="sd">    estimators see documentation for the child classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default estimator settings.&quot;&quot;&quot;</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;local_values&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_start_jvm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start JAVA virtual machine if it is not running.&quot;&quot;&quot;</span>
        <span class="n">jar_location</span> <span class="o">=</span> <span class="n">resource_filename</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;infodynamics.jar&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">jp</span><span class="o">.</span><span class="n">isJVMStarted</span><span class="p">():</span>
            <span class="n">jp</span><span class="o">.</span><span class="n">startJVM</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">getDefaultJVMPath</span><span class="p">(),</span> <span class="s1">&#39;-ea&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;-Djava.class.path=&#39;</span> <span class="o">+</span>
                                                        <span class="n">jar_location</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_set_te_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set defaults for transfer entropy estimation.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">history_target</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No target history was provided for TE &#39;</span>
                               <span class="s1">&#39;estimation.&#39;</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;history_source&#39;</span><span class="p">,</span> <span class="n">history_target</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tau_target&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tau_source&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_target&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Target tau has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_source&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Source tau has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Target history has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Source history has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Source-target delay has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_target&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Target tau must be &gt;= 1&#39;</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_source&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Source tau must be &gt;= 1&#39;</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Target history must be &gt;= 0&#39;</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Source history must be &gt;= 1&#39;</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Source-target delay must be &gt;= 0&#39;</span>
        <span class="k">return</span> <span class="n">settings</span>

<div class="viewcode-block" id="JidtEstimator.is_parallel"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtEstimator.is_parallel">[docs]</a>    <span class="k">def</span> <span class="nf">is_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="JidtKraskov"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskov">[docs]</a><span class="k">class</span> <span class="nc">JidtKraskov</span><span class="p">(</span><span class="n">JidtEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for implementation of JIDT Kraskov-estimators.</span>

<span class="sd">    Abstract class for implementation of JIDT Kraskov-estimators, child classes</span>
<span class="sd">    implement estimators for mutual information (MI), conditional mutual</span>
<span class="sd">    information (CMI), actice information storage (AIS), transfer entropy (TE)</span>
<span class="sd">    using the Kraskov-Grassberger-Stoegbauer estimator for continuous data.</span>
<span class="sd">    See parent class for references.</span>

<span class="sd">    Set common estimation parameters for JIDT Kraskov-estimators. For usage of</span>
<span class="sd">    these estimators see documentation for the child classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        CalcClass : JAVA class</span>
<span class="sd">            JAVA class returned by jpype.JPackage</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - kraskov_k : int [optional] - no. nearest neighbours for KNN</span>
<span class="sd">              search (default=4)</span>
<span class="sd">            - normalise : bool [optional] - z-standardise data (default=False)</span>
<span class="sd">            - theiler_t : int [optional] - no. next temporal neighbours ignored</span>
<span class="sd">              in KNN and range searches (default=0)</span>
<span class="sd">            - noise_level : float [optional] - random noise added to the data</span>
<span class="sd">              (default=1e-8)</span>
<span class="sd">            - num_threads : int | str [optional] - number of threads used for</span>
<span class="sd">              estimation (default=&#39;USE_ALL&#39;, note that this uses *all*</span>
<span class="sd">              available threads on the current machine)</span>
<span class="sd">            - algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)</span>
<span class="sd">              to use (default=1). Only applied at this method for TE and AIS</span>
<span class="sd">              (is already applied for MI/CMI). Note that default algorithm of 1</span>
<span class="sd">              here is different to the default ALG_NUM argument for the JIDT</span>
<span class="sd">              AIS KSG estimator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Set default estimator settings.</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;kraskov_k&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;normalise&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;theiler_t&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;noise_level&#39;</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;num_threads&#39;</span><span class="p">,</span> <span class="s1">&#39;USE_ALL&#39;</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be 1 or 2&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Set properties of JIDT&#39;s estimator object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">CalcClass</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;ALG_NUM&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;NORMALISE&#39;</span><span class="p">,</span>
                              <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;normalise&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;kraskov_k&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;DYN_CORR_EXCL&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;theiler_t&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;NOISE_LEVEL_TO_ADD&#39;</span><span class="p">,</span>
                              <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;noise_level&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s1">&#39;NUM_THREADS&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;num_threads&#39;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="JidtKraskov.is_analytic_null_estimator"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">is_analytic_null_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="JidtDiscrete"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscrete">[docs]</a><span class="k">class</span> <span class="nc">JidtDiscrete</span><span class="p">(</span><span class="n">JidtEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for implementation of discrete JIDT-estimators.</span>

<span class="sd">    Abstract class for implementation of plug-in JIDT-estimators for discrete</span>
<span class="sd">    data. Child classes implement estimators for mutual information (MI),</span>
<span class="sd">    conditional mutual information (CMI), actice information storage (AIS), and</span>
<span class="sd">    transfer entropy (TE). See parent class for references.</span>

<span class="sd">    Set common estimation parameters for discrete JIDT-estimators. For usage of</span>
<span class="sd">    these estimators see documentation for the child classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - discretise_method : str [optional] - if and how to discretise</span>
<span class="sd">              incoming continuous data, can be &#39;max_ent&#39; for maximum entropy</span>
<span class="sd">              binning, &#39;equal&#39; for equal size bins, and &#39;none&#39; if no binning is</span>
<span class="sd">              required (default=&#39;none&#39;)</span>

<span class="sd">    Note:</span>
<span class="sd">        Discrete JIDT estimators require the data&#39;s alphabet size for</span>
<span class="sd">        instantiation. Hence, opposed to the Kraskov and Gaussian estimators,</span>
<span class="sd">        the JAVA class is added to the object instance, while for Kraskov/</span>
<span class="sd">        Gaussian estimators an instance of that class is added (because for the</span>
<span class="sd">        latter, objects can be instantiated independent of data properties).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_discretise_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Discretise variables if requested. Otherwise assert data are discrete</span>
        <span class="c1"># and provided alphabet sizes are correct.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;equal&#39;</span><span class="p">:</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">])</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">conditional</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">conditional</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;max_ent&#39;</span><span class="p">:</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise_max_ent</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">])</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise_max_ent</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">conditional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">conditional</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise_max_ent</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Var1 is not an integer numpy array. &#39;</span>
                <span class="s1">&#39;Discretise data to use this estimator.&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">var2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Var2 is not an integer numpy array. &#39;</span>
                <span class="s1">&#39;Discretise data to use this estimator.&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Minimum of var1 is smaller than 0.&#39;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Minimum of var2 is smaller than 0.&#39;</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">],</span> <span class="p">(</span>
                        <span class="s1">&#39;Maximum of var1 is larger than the alphabet size.&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">],</span> <span class="p">(</span>
                        <span class="s1">&#39;Maximum of var2 is larger than the alphabet size.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conditional</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
                        <span class="s1">&#39;Minimum of conditional is smaller than 0.&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">conditional</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span> <span class="p">(</span>
                    <span class="s1">&#39;Conditional is not an integer numpy array. &#39;</span>
                    <span class="s1">&#39;Discretise data to use this estimator.&#39;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">],</span> <span class="p">(</span>
                    <span class="s1">&#39;Maximum of conditional is larger than the alphabet size.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unkown discretisation method.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conditional</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span>

<div class="viewcode-block" id="JidtDiscrete.is_analytic_null_estimator"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">is_analytic_null_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="JidtDiscrete.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            data : numpy arrays</span>
<span class="sd">                realisations of random variables required for the calculation</span>
<span class="sd">                (varies between estimators, e.g. 2 variables for MI, 3 for</span>
<span class="sd">                CMI). Formatted as per the estimate method for this estimator.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="JidtDiscrete.estimate_surrogates_analytic"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_surrogates_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_perm</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return estimate of the analytical surrogate distribution.</span>

<span class="sd">        This method must be implemented because this class&#39;</span>
<span class="sd">        is_analytic_null_estimator() method returns true.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_perms : int [optional]</span>
<span class="sd">                number of permutations (default=200)</span>
<span class="sd">            data : numpy arrays</span>
<span class="sd">                realisations of random variables required for the calculation</span>
<span class="sd">                (varies between estimators, e.g. 2 variables for MI, 3 for</span>
<span class="sd">                CMI). Formatted as per the estimate method for this estimator.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                n_perm surrogates of the average MI/CMI/TE over all samples</span>
<span class="sd">                under the null hypothesis of no relationship between var1 and</span>
<span class="sd">                var2 (in the context of conditional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">common_estimate_surrogates_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="JidtGaussian"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussian">[docs]</a><span class="k">class</span> <span class="nc">JidtGaussian</span><span class="p">(</span><span class="n">JidtEstimator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for implementation of JIDT Gaussian-estimators.</span>

<span class="sd">    Abstract class for implementation of JIDT Gaussian-estimators, child</span>
<span class="sd">    classes implement estimators for mutual information (MI), conditional</span>
<span class="sd">    mutual information (CMI), actice information storage (AIS), transfer</span>
<span class="sd">    entropy (TE) using JIDT&#39;s Gaussian estimator for continuous data. See</span>
<span class="sd">    parent class for references.</span>

<span class="sd">    Set common estimation parameters for JIDT Kraskov-estimators. For usage of</span>
<span class="sd">    these estimators see documentation for the child classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        CalcClass : JAVA class</span>
<span class="sd">            JAVA class returned by jpype.JPackage</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span> <span class="o">=</span> <span class="n">CalcClass</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="JidtGaussian.is_analytic_null_estimator"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator">[docs]</a>    <span class="k">def</span> <span class="nf">is_analytic_null_estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="JidtGaussian.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            data : numpy arrays</span>
<span class="sd">                realisations of random variables required for the calculation</span>
<span class="sd">                (varies between estimators, e.g. 2 variables for MI, 3 for</span>
<span class="sd">                CMI). Formatted as per the estimate method for this estimator.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div>

<div class="viewcode-block" id="JidtGaussian.estimate_surrogates_analytic"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_surrogates_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_perm</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the surrogate distribution analytically.</span>

<span class="sd">        This method must be implemented because this class&#39;</span>
<span class="sd">        is_analytic_null_estimator() method returns true</span>

<span class="sd">        Args:</span>
<span class="sd">            n_perms : int</span>
<span class="sd">                number of permutations (default=200)</span>
<span class="sd">            data : numpy arrays</span>
<span class="sd">                realisations of random variables required for the calculation</span>
<span class="sd">                (varies between estimators, e.g. 2 variables for MI, 3 for</span>
<span class="sd">                CMI). Formatted as per estimate_parallel for this estimator.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                n_perm surrogates of the average MI/CMI/TE over all samples</span>
<span class="sd">                under the null hypothesis of no relationship between var1 and</span>
<span class="sd">                var2 (in the context of conditional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">common_estimate_surrogates_analytic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="JidtKraskovCMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovCMI">[docs]</a><span class="k">class</span> <span class="nc">JidtKraskovCMI</span><span class="p">(</span><span class="n">JidtKraskov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate conditional mutual inform with JIDT&#39;s Kraskov implementation.</span>

<span class="sd">    Calculate the conditional mutual information (CMI) between three variables.</span>
<span class="sd">    Call JIDT via jpype and use the Kraskov 1 estimator. If no conditional is</span>
<span class="sd">    given (is None), the function returns the mutual information between var1</span>
<span class="sd">    and var2. See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - kraskov_k : int [optional] - no. nearest neighbours for KNN</span>
<span class="sd">              search (default=4)</span>
<span class="sd">            - normalise : bool [optional] - z-standardise data (default=False)</span>
<span class="sd">            - theiler_t : int [optional] - no. next temporal neighbours ignored</span>
<span class="sd">              in KNN and range searches (default=0)</span>
<span class="sd">            - noise_level : float [optional] - random noise added to the data</span>
<span class="sd">              (default=1e-8)</span>
<span class="sd">            - num_threads : int | str [optional] - number of threads used for</span>
<span class="sd">              estimation (default=&#39;USE_ALL&#39;, note that this uses *all*</span>
<span class="sd">              available threads on the current machine)</span>
<span class="sd">            - algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)</span>
<span class="sd">              to use (default=1)</span>
<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the CMI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        CMI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be 1 or 2&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">ConditionalMutualInfoCalculatorMultiVariateKraskov1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">ConditionalMutualInfoCalculatorMultiVariateKraskov2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<div class="viewcode-block" id="JidtKraskovCMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovCMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate conditional mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            conditional : numpy array [optional]</span>
<span class="sd">                realisations of the conditioning variable (similar to var), if</span>
<span class="sd">                no conditional is provided, return MI between var1 and var2</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average CMI over all samples or local CMI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return MI if no conditional was provided.</span>
        <span class="k">if</span> <span class="n">conditional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">est_mi</span> <span class="o">=</span> <span class="n">JidtKraskovMI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">est_mi</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">conditional</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Conditional Array is empty.&#39;</span>

        <span class="c1"># Check if variable realisations are passed as 1D or 2D arrays and have</span>
        <span class="c1"># equal no. observations.</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span>
            <span class="s1">&#39;Unequal number of observations (var1: </span><span class="si">{0}</span><span class="s1">, var2: </span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span>
            <span class="s1">&#39;Unequal number of observations (var1: </span><span class="si">{0}</span><span class="s1">, cond: </span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Check if number of points is sufficient for estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_of_points</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtDiscreteCMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteCMI">[docs]</a><span class="k">class</span> <span class="nc">JidtDiscreteCMI</span><span class="p">(</span><span class="n">JidtDiscrete</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate CMI with JIDT&#39;s implementation for discrete variables.</span>

<span class="sd">    Calculate the conditional mutual information between two variables given</span>
<span class="sd">    the third. Call JIDT via jpype and use the discrete estimator. See parent</span>
<span class="sd">    class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - discretise_method : str [optional] - if and how to discretise</span>
<span class="sd">              incoming continuous data, can be &#39;max_ent&#39; for maximum entropy</span>
<span class="sd">              binning, &#39;equal&#39; for equal size bins, and &#39;none&#39; if no binning is</span>
<span class="sd">              required (default=&#39;none&#39;)</span>
<span class="sd">            - n_discrete_bins : int [optional] - number of discrete bins/</span>
<span class="sd">              levels or the base of each dimension of the discrete variables</span>
<span class="sd">              (default=2). If set, this parameter overwrites/sets alph1, alph2</span>
<span class="sd">              and alphc</span>
<span class="sd">            - alph1 : int [optional] - number of discrete bins/levels for var1</span>
<span class="sd">              (default=2, or the value set for n_discrete_bins)</span>
<span class="sd">            - alph2 : int [optional] - number of discrete bins/levels for var2</span>
<span class="sd">              (default=2, or the value set for n_discrete_bins)</span>
<span class="sd">            - alphc : int [optional] - number of discrete bins/levels for</span>
<span class="sd">              conditional (default=2, or the value set for n_discrete_bins)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Set default alphabet sizes. Try to overwrite alphabet sizes with</span>
        <span class="c1"># number of bins for discretisation if provided, otherwise assume</span>
        <span class="c1"># binary variables.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_discrete_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_discrete_bins&#39;</span><span class="p">])</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Do nothing and use the default for alph_* set below</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph1&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph2&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alphc&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object. Add JAVA object to</span>
        <span class="c1"># instance, the discrete estimator requires the variable dimensions</span>
        <span class="c1"># upon instantiation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.discrete&#39;</span><span class="p">)</span><span class="o">.</span>
                          <span class="n">ConditionalMutualInformationCalculatorDiscrete</span><span class="p">)</span>

<div class="viewcode-block" id="JidtDiscreteCMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteCMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate conditional mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            conditional : numpy array [optional]</span>
<span class="sd">                realisations of the conditioning variable (similar to var), if</span>
<span class="sd">                no conditional is provided, return MI between var1 and var2</span>
<span class="sd">            return_calc : boolean</span>
<span class="sd">                return the calculator used here as well as the numeric</span>
<span class="sd">                calculated value(s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average CMI over all samples or local CMI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here. Only returned if</span>
<span class="sd">                return_calc was set.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ex.JidtOutOfMemoryError</span>
<span class="sd">                Raised when JIDT object cannot be instantiated due to mem error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate an MI if no conditional was provided</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">conditional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">est</span> <span class="o">=</span> <span class="n">JidtDiscreteMI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
            <span class="c1"># Return value will be just the estimate if return_calc is False,</span>
            <span class="c1">#  or estimate plus the JIDT MI calculator if return_calc is True:</span>
            <span class="k">return</span> <span class="n">est</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">return_calc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">conditional</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Conditional Array is empty.&#39;</span>

        <span class="c1"># Check and remember the no. dimensions for each variable before</span>
        <span class="c1"># collapsing them into univariate arrays later.</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
        <span class="n">conditional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span>
        <span class="n">var1_dim</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">var2_dim</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cond_dim</span> <span class="o">=</span> <span class="n">conditional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Discretise if requested.</span>
        <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretise_vars</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span>
                                                        <span class="n">conditional</span><span class="p">)</span>

        <span class="c1"># Then collapse any mulitvariates into univariate arrays:</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_discrete_dimensions</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">])</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_discrete_dimensions</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span>
        <span class="n">conditional</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_discrete_dimensions</span><span class="p">(</span><span class="n">conditional</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">])</span>

        <span class="c1"># We have a non-trivial conditional, so make a proper conditional MI</span>
        <span class="c1"># calculation</span>
        <span class="n">alph1_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">],</span> <span class="n">var1_dim</span><span class="p">))</span>
        <span class="n">alph2_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">],</span> <span class="n">var2_dim</span><span class="p">))</span>
        <span class="n">cond_base</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alphc&#39;</span><span class="p">],</span> <span class="n">cond_dim</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span><span class="p">(</span><span class="n">alph1_base</span><span class="p">,</span> <span class="n">alph2_base</span><span class="p">,</span> <span class="n">cond_base</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">jp</span><span class="o">.</span><span class="n">JavaException</span><span class="p">:</span>
            <span class="c1"># Only possible exception that can be raised here</span>
            <span class="c1">#  (if all bases &gt;= 2) is a Java OutOfMemoryException:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">alph1_base</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">alph2_base</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">cond_base</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ex</span><span class="o">.</span><span class="n">JidtOutOfMemoryError</span><span class="p">(</span><span class="s1">&#39;Cannot instantiate JIDT CMI &#39;</span>
                <span class="s1">&#39;discrete estimator with alph1_base = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">alph1_base</span><span class="p">)</span> <span class="o">+</span>
                <span class="s1">&#39;, alph2_base = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">alph2_base</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, cond_base = &#39;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">cond_base</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. Try re-running increasing Java heap size&#39;</span><span class="p">)</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">])</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="c1"># Unfortunately no faster way to pass numpy arrays in than this list</span>
        <span class="c1"># conversion</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                             <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                             <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">conditional</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalFromPreviousObservations</span><span class="p">(</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">conditional</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_calc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">calc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="JidtDiscreteCMI.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            conditional : numpy array [optional]</span>
<span class="sd">                realisations of the conditioning variable (similar to var), if</span>
<span class="sd">                no conditional is provided, return MI between var1 and var2</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">jidt_calc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jidt_calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtDiscreteMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteMI">[docs]</a><span class="k">class</span> <span class="nc">JidtDiscreteMI</span><span class="p">(</span><span class="n">JidtDiscrete</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate MI with JIDT&#39;s discrete-variable implementation.</span>

<span class="sd">    Calculate the mutual information (MI) between two variables. Call JIDT via</span>
<span class="sd">    jpype and use the discrete estimator. See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - discretise_method : str [optional] - if and how to discretise</span>
<span class="sd">              incoming continuous data, can be &#39;max_ent&#39; for maximum entropy</span>
<span class="sd">              binning, &#39;equal&#39; for equal size bins, and &#39;none&#39; if no binning is</span>
<span class="sd">              required (default=&#39;none&#39;)</span>
<span class="sd">            - n_discrete_bins : int [optional] - number of discrete bins/</span>
<span class="sd">              levels or the base of each dimension of the discrete variables</span>
<span class="sd">              (default=2). If set, this parameter overwrites/sets alph1 and</span>
<span class="sd">              alph2</span>
<span class="sd">            - alph1 : int [optional] - number of discrete bins/levels for var1</span>
<span class="sd">              (default=2, or the value set for n_discrete_bins)</span>
<span class="sd">            - alph2 : int [optional] - number of discrete bins/levels for var2</span>
<span class="sd">              (default=2, or the value set for n_discrete_bins)</span>
<span class="sd">            - lag_mi : int [optional] - time difference in samples to calculate</span>
<span class="sd">              the lagged MI between processes (default=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Set default alphabet sizes. Try to overwrite alphabet sizes with</span>
        <span class="c1"># number of bins for discretisation if provided, otherwise assume</span>
        <span class="c1"># binary variables.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_discrete_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_discrete_bins&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Do nothing and use the default for alph_* set below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph1&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph2&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object. Add JAVA object to</span>
        <span class="c1"># instance, the discrete estimator requires the variable dimensions</span>
        <span class="c1"># upon instantiation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.discrete&#39;</span><span class="p">)</span><span class="o">.</span>
                          <span class="n">MutualInformationCalculatorDiscrete</span><span class="p">)</span>

<div class="viewcode-block" id="JidtDiscreteMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">return_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            return_calc : boolean</span>
<span class="sd">                return the calculator used here as well as the numeric</span>
<span class="sd">                calculated value(s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average MI over all samples or local MI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here. Only returned if</span>
<span class="sd">                return_calc was set.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ex.JidtOutOfMemoryError</span>
<span class="sd">                Raised when JIDT object cannot be instantiated due to mem error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check and remember the no. dimensions for each variable before</span>
        <span class="c1"># collapsing them into univariate arrays later.</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
        <span class="n">var1_dim</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">var2_dim</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Discretise variables if requested.</span>
        <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretise_vars</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>

        <span class="c1"># Then collapse any mulitvariates into univariate arrays:</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_discrete_dimensions</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">])</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_discrete_dimensions</span><span class="p">(</span><span class="n">var2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span>

        <span class="c1"># Initialise estimator</span>
        <span class="n">base_for_var1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">],</span> <span class="n">var1_dim</span><span class="p">))</span>
        <span class="n">base_for_var2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">],</span> <span class="n">var2_dim</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span><span class="p">(</span><span class="n">base_for_var1</span><span class="p">,</span> <span class="n">base_for_var2</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">jp</span><span class="o">.</span><span class="n">JavaException</span><span class="p">:</span>
            <span class="c1"># Only possible exception that can be raised here</span>
            <span class="c1">#  (if base_for_var* &gt;= 2) is a Java OutOfMemoryException:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">base_for_var1</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">base_for_var2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ex</span><span class="o">.</span><span class="n">JidtOutOfMemoryError</span><span class="p">(</span><span class="s1">&#39;Cannot instantiate JIDT MI &#39;</span>
                <span class="s1">&#39;discrete estimator with bases = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">base_for_var1</span><span class="p">)</span> <span class="o">+</span>
                 <span class="s1">&#39; and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">base_for_var2</span><span class="p">)</span> <span class="o">+</span>
                 <span class="s1">&#39;. Try re-running increasing Java heap size&#39;</span><span class="p">)</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">setDebug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">])</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>

        <span class="c1"># Unfortunately no faster way to pass numpy arrays in than this list</span>
        <span class="c1"># conversion</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                             <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalFromPreviousObservations</span><span class="p">(</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var1</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">var2</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_calc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">calc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="JidtDiscreteMI.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">jidt_calc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jidt_calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtKraskovMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovMI">[docs]</a><span class="k">class</span> <span class="nc">JidtKraskovMI</span><span class="p">(</span><span class="n">JidtKraskov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate mutual information with JIDT&#39;s Kraskov implementation.</span>

<span class="sd">    Calculate the mutual information between two variables. Call JIDT via jpype</span>
<span class="sd">    and use the Kraskov 1 estimator. See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - kraskov_k : int [optional] - no. nearest neighbours for KNN</span>
<span class="sd">              search (default=4)</span>
<span class="sd">            - normalise : bool [optional] - z-standardise data (default=False)</span>
<span class="sd">            - theiler_t : int [optional] - no. next temporal neighbours ignored</span>
<span class="sd">              in KNN and range searches (default=0)</span>
<span class="sd">            - noise_level : float [optional] - random noise added to the data</span>
<span class="sd">              (default=1e-8)</span>
<span class="sd">            - num_threads : int | str [optional] - number of threads used for</span>
<span class="sd">              estimation (default=&#39;USE_ALL&#39;, note that this uses *all*</span>
<span class="sd">              available threads on the current machine)</span>
<span class="sd">            - algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)</span>
<span class="sd">              to use (default=1)</span>
<span class="sd">            - lag_mi : int [optional] - time difference in samples to calculate</span>
<span class="sd">              the lagged MI between processes (default=0)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the MI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        MI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;Algorithm number must be 1 or 2&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;algorithm_num&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">MutualInfoCalculatorMultiVariateKraskov1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">MutualInfoCalculatorMultiVariateKraskov2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Get lag and shift second variable to account for a lag if requested</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="JidtKraskovMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average MI over all samples or local MI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if variable realisations are passed as 1D or 2D arrays</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>

        <span class="c1"># Shift variables to calculate a lagged MI.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">var1</span><span class="p">[:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="n">var2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">]:,</span> <span class="p">:]</span>

        <span class="c1"># Check if number of points is sufficient for estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_of_points</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtKraskovAIS"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovAIS">[docs]</a><span class="k">class</span> <span class="nc">JidtKraskovAIS</span><span class="p">(</span><span class="n">JidtKraskov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate active information storage with JIDT&#39;s Kraskov implementation.</span>

<span class="sd">    Calculate active information storage (AIS) for some process using JIDT&#39;s</span>
<span class="sd">    implementation of the Kraskov type 1 estimator. AIS is defined as the</span>
<span class="sd">    mutual information between the processes&#39; past state and current value.</span>

<span class="sd">    The past state needs to be defined in the settings dictionary, where a past</span>
<span class="sd">    state is defined as a uniform embedding with parameters history and tau.</span>
<span class="sd">    The history describes the number of samples taken from a processes&#39; past,</span>
<span class="sd">    tau describes the embedding delay, i.e., the spacing between every two</span>
<span class="sd">    samples from the processes&#39; past.</span>

<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - history : int - number of samples in the processes&#39; past used as</span>
<span class="sd">              embedding</span>
<span class="sd">            - tau : int [optional] - the processes&#39; embedding delay (default=1)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - kraskov_k : int [optional] - no. nearest neighbours for KNN</span>
<span class="sd">              search (default=4)</span>
<span class="sd">            - normalise : bool [optional] - z-standardise data (default=False)</span>
<span class="sd">            - theiler_t : int [optional] - no. next temporal neighbours ignored</span>
<span class="sd">              in KNN and range searches (default=0)</span>
<span class="sd">            - noise_level : float [optional] - random noise added to the data</span>
<span class="sd">              (default=1e-8)</span>
<span class="sd">            - num_threads : int | str [optional] - number of threads used for</span>
<span class="sd">              estimation (default=&#39;USE_ALL&#39;, note that this uses *all*</span>
<span class="sd">              available threads on the current machine)</span>
<span class="sd">            - algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)</span>
<span class="sd">              to use (default=1)</span>
<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the AIS estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        AIS estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Check for history for AIS estimation.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No history was provided for AIS estimation.&#39;</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tau&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
                                            <span class="s1">&#39;History has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Tau has to be an integer.&#39;</span><span class="p">)</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">ActiveInfoStorageCalculatorKraskov</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<div class="viewcode-block" id="JidtKraskovAIS.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovAIS.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate active information storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            process : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average AIS over all samples or local AIS for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="c1"># Check if number of points is sufficient for estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_of_points</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtDiscreteAIS"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteAIS">[docs]</a><span class="k">class</span> <span class="nc">JidtDiscreteAIS</span><span class="p">(</span><span class="n">JidtDiscrete</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate AIS with JIDT&#39;s discrete-variable implementation.</span>

<span class="sd">    Calculate the active information storage (AIS) for one process. Call JIDT</span>
<span class="sd">    via jpype and use the discrete estimator. See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            set estimator parameters:</span>

<span class="sd">            - history : int - number of samples in the target&#39;s past used as</span>
<span class="sd">              embedding (&gt;= 0)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - discretise_method : str [optional] - if and how to discretise</span>
<span class="sd">              incoming continuous data, can be &#39;max_ent&#39; for maximum entropy</span>
<span class="sd">              binning, &#39;equal&#39; for equal size bins, and &#39;none&#39; if no binning is</span>
<span class="sd">              required (default=&#39;none&#39;)</span>
<span class="sd">            - n_discrete_bins : int [optional] - number of discrete bins/</span>
<span class="sd">              levels or the base of each dimension of the discrete variables</span>
<span class="sd">              (default=2). If set, this parameter overwrites/sets alph. (&gt;= 2)</span>
<span class="sd">            - alph : int [optional] - number of discrete bins/levels for var1</span>
<span class="sd">              (default=2 , or the value set for n_discrete_bins). (&gt;= 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No history was provided for AIS estimation.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
                                            <span class="s1">&#39;History has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;History must be &gt;= 0&#39;</span>

        <span class="c1"># Get alphabet sizes and check if discretisation is requested</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_discrete_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_discrete_bins&#39;</span><span class="p">])</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Do nothing and use the default for alph set below</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Number of bins must be &gt;= 2&#39;</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.discrete&#39;</span><span class="p">)</span><span class="o">.</span>
                          <span class="n">ActiveInformationCalculatorDiscrete</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

<div class="viewcode-block" id="JidtDiscreteAIS.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteAIS.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">return_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate active information storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            process : numpy array</span>
<span class="sd">                realisations as either a 2D numpy array where array dimensions</span>
<span class="sd">                represent [realisations x variable dimension] or a 1D array</span>
<span class="sd">                representing [realisations], array type can be float (requires</span>
<span class="sd">                discretisation) or int</span>
<span class="sd">            return_calc : boolean</span>
<span class="sd">                return the calculator used here as well as the numeric</span>
<span class="sd">                calculated value(s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average AIS over all samples or local AIS for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here. Only returned if</span>
<span class="sd">                return_calc was set.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ex.JidtOutOfMemoryError</span>
<span class="sd">                Raised when JIDT object cannot be instantiated due to mem error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="c1"># Now discretise if required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Process is not an integer numpy array. &#39;</span>
                <span class="s1">&#39;Discretise data to use this estimator.&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">process</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Minimum of process is smaller than 0.&#39;</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">process</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">],</span> <span class="p">(</span>
                <span class="s1">&#39;Maximum of process is larger than the alphabet size.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">process</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The process&#39;&#39; alphabet size does not match&#39;</span>
                                   <span class="s1">&#39; the no. unique elements in the process.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;equal&#39;</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;discretise_method&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;max_ent&#39;</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">discretise_max_ent</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># don&#39;t discretise at all, assume data to be discrete</span>

        <span class="c1"># And finally make the AIS calculation:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">jp</span><span class="o">.</span><span class="n">JavaException</span><span class="p">:</span>
            <span class="c1"># Only possible exception that can be raised here</span>
            <span class="c1">#  (if self.settings[&#39;alph&#39;] &gt;= 2) is a Java OutOfMemoryException:</span>
            <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ex</span><span class="o">.</span><span class="n">JidtOutOfMemoryError</span><span class="p">(</span><span class="s1">&#39;Cannot instantiate JIDT AIS &#39;</span>
                <span class="s1">&#39;discrete estimator with alph = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph&#39;</span><span class="p">])</span> <span class="o">+</span>
                 <span class="s1">&#39; and history = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span> <span class="o">+</span>
                 <span class="s1">&#39;. Try re-running increasing Java heap size&#39;</span><span class="p">)</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="c1"># Unfortunately no faster way to pass numpy arrays in than this list</span>
        <span class="c1"># conversion</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">process</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalFromPreviousObservations</span><span class="p">(</span>
                                    <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">process</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_calc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">calc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="JidtDiscreteAIS.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            process : numpy array</span>
<span class="sd">                realisations as either a 2D numpy array where array dimensions</span>
<span class="sd">                represent [realisations x variable dimension] or a 1D array</span>
<span class="sd">                representing [realisations], array type can be float (requires</span>
<span class="sd">                discretisation) or int</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">jidt_calc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jidt_calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtGaussianAIS"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianAIS">[docs]</a><span class="k">class</span> <span class="nc">JidtGaussianAIS</span><span class="p">(</span><span class="n">JidtGaussian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate active information storage with JIDT&#39;s Gaussian implementation.</span>

<span class="sd">    Calculate active information storage (AIS) for some process using JIDT&#39;s</span>
<span class="sd">    implementation of the Gaussian estimator. AIS is defined as the</span>
<span class="sd">    mutual information between the processes&#39; past state and current value.</span>

<span class="sd">    The past state needs to be defined in the settings dictionary, where a past</span>
<span class="sd">    state is defined as a uniform embedding with parameters history and tau.</span>
<span class="sd">    The history describes the number of samples taken from a processes&#39; past,</span>
<span class="sd">    tau describes the embedding delay, i.e., the spacing between every two</span>
<span class="sd">    samples from the processes&#39; past.</span>

<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - history : int - number of samples in the processes&#39; past used as</span>
<span class="sd">              embedding</span>
<span class="sd">            - tau : int [optional] - the processes&#39; embedding delay (default=1)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the AIS estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        AIS estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Check for history for AIS estimation.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No history was provided for AIS estimation.&#39;</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tau&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
                                            <span class="s1">&#39;History has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Tau has to be an integer.&#39;</span><span class="p">)</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.gaussian&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">ActiveInfoStorageCalculatorGaussian</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<div class="viewcode-block" id="JidtGaussianAIS.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianAIS.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate active information storage.</span>

<span class="sd">        Args:</span>
<span class="sd">            process : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average AIS over all samples or local AIS for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtGaussianMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianMI">[docs]</a><span class="k">class</span> <span class="nc">JidtGaussianMI</span><span class="p">(</span><span class="n">JidtGaussian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate mutual information with JIDT&#39;s Gaussian implementation.</span>

<span class="sd">    Calculate the mutual information between two variables. Call JIDT via jpype</span>
<span class="sd">    and use the Gaussian estimator. See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - lag_mi : int [optional] - time difference in samples to calculate</span>
<span class="sd">              the lagged MI between processes (default=0)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the MI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        MI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.gaussian&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">MutualInfoCalculatorMultiVariateGaussian</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Add lag between input variables. Setting the lag in JIDT didn&#39;t work,</span>
        <span class="c1"># shift variables when calling the estimate method instead.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># self.calc.setProperty(&#39;PROP_TIME_DIFF&#39;, str(self.settings[&#39;lag_mi&#39;]))</span>

<div class="viewcode-block" id="JidtGaussianMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average MI over all samples or local MI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>

        <span class="c1"># Shift variables to calculate a lagged MI.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="n">var1</span><span class="p">[:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="n">var2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;lag_mi&#39;</span><span class="p">]:,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtGaussianCMI"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianCMI">[docs]</a><span class="k">class</span> <span class="nc">JidtGaussianCMI</span><span class="p">(</span><span class="n">JidtGaussian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate conditional mutual infor with JIDT&#39;s Gaussian implementation.</span>

<span class="sd">    Computes the differential conditional mutual information of two</span>
<span class="sd">    multivariate sets of observations, conditioned on another, assuming that</span>
<span class="sd">    the probability distribution function for these observations is a</span>
<span class="sd">    multivariate Gaussian distribution.</span>
<span class="sd">    Call JIDT via jpype and use</span>
<span class="sd">    ConditionalMutualInfoCalculatorMultiVariateGaussian estimator.</span>
<span class="sd">    If no conditional is given (is None), the function returns the mutual</span>
<span class="sd">    information between var1 and var2.</span>

<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the CMI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        CMI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.gaussian&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">ConditionalMutualInfoCalculatorMultiVariateGaussian</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">est_mi</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="JidtGaussianCMI.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianCMI.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate conditional mutual information.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            conditional : numpy array [optional]</span>
<span class="sd">                realisations of the conditioning variable (similar to var), if</span>
<span class="sd">                no conditional is provided, return MI between var1 and var2</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average CMI over all samples or local CMI for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return MI if no conditioning variable was provided.</span>
        <span class="k">if</span> <span class="n">conditional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">est_mi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">est_mi</span> <span class="o">=</span> <span class="n">JidtGaussianMI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_mi</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">conditional</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;Conditional Array is empty.&#39;</span>

        <span class="n">var1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_two_dim_input</span><span class="p">(</span><span class="n">conditional</span><span class="p">)</span>

        <span class="k">assert</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span>
            <span class="s1">&#39;Unequal number of observations (var1: </span><span class="si">{0}</span><span class="s1">, var2: </span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span>
            <span class="s1">&#39;Unequal number of observations (var1: </span><span class="si">{0}</span><span class="s1">, cond: </span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">var2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div>

<div class="viewcode-block" id="JidtGaussianCMI.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            var1 : numpy array</span>
<span class="sd">                realisations of first variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of the second variable (similar to var1)</span>
<span class="sd">            conditional : numpy array [optional]</span>
<span class="sd">                realisations of the conditioning variable (similar to var), if</span>
<span class="sd">                no conditional is provided, return MI between var1 and var2</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">var1</span><span class="p">,</span> <span class="n">var2</span><span class="p">,</span> <span class="n">conditional</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">conditional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">est_mi</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtKraskovTE"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovTE">[docs]</a><span class="k">class</span> <span class="nc">JidtKraskovTE</span><span class="p">(</span><span class="n">JidtKraskov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate transfer entropy with JIDT&#39;s Kraskov implementation.</span>

<span class="sd">    Calculate transfer entropy between a source and a target variable using</span>
<span class="sd">    JIDT&#39;s implementation of the Kraskov type 1 estimator. Transfer entropy is</span>
<span class="sd">    defined as the conditional mutual information between the source&#39;s past</span>
<span class="sd">    state and the target&#39;s current value, conditional on the target&#39;s past.</span>

<span class="sd">    Past states need to be defined in the settings dictionary, where a past</span>
<span class="sd">    state is defined as a uniform embedding with parameters history and tau.</span>
<span class="sd">    The history describes the number of samples taken from a variable&#39;s past,</span>
<span class="sd">    tau descrices the embedding delay, i.e., the spacing between every two</span>
<span class="sd">    samples from the processes&#39; past.</span>

<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - history_target : int - number of samples in the target&#39;s past</span>
<span class="sd">              used as embedding</span>
<span class="sd">            - history_source  : int [optional] - number of samples in the</span>
<span class="sd">              source&#39;s past used as embedding (default=same as the target</span>
<span class="sd">              history)</span>
<span class="sd">            - tau_source : int [optional] - source&#39;s embedding delay</span>
<span class="sd">              (default=1)</span>
<span class="sd">            - tau_target : int [optional] - target&#39;s embedding delay</span>
<span class="sd">              (default=1)</span>
<span class="sd">            - source_target_delay : int [optional] - information transfer delay</span>
<span class="sd">              between source and target (default=1)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">            - algorithm_num : int [optional] - which Kraskov algorithm (1 or 2)</span>
<span class="sd">              to use (default=1)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the CMI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        CMI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.kraskov&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">TransferEntropyCalculatorKraskov</span><span class="p">)</span>
        <span class="c1"># Get embedding and delay parameters.</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_te_defaults</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>


<div class="viewcode-block" id="JidtKraskovTE.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtKraskovTE.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate transfer entropy from a source to a target variable.</span>

<span class="sd">        Args:</span>
<span class="sd">            source : numpy array</span>
<span class="sd">                realisations of source variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of target variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average TE over all samples or local TE for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Check if number of points is sufficient for estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_number_of_points</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_target&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_source&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtDiscreteTE"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteTE">[docs]</a><span class="k">class</span> <span class="nc">JidtDiscreteTE</span><span class="p">(</span><span class="n">JidtDiscrete</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate TE with JIDT&#39;s implementation for discrete variables.</span>

<span class="sd">    Calculate the transfer entropy between two time series processes.</span>
<span class="sd">    Call JIDT via jpype and use the discrete estimator. Transfer entropy is</span>
<span class="sd">    defined as the conditional mutual information between the source&#39;s past</span>
<span class="sd">    state and the target&#39;s current value, conditional on the target&#39;s past.</span>
<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - history_target : int - number of samples in the target&#39;s past</span>
<span class="sd">              used as embedding. (&gt;= 0)</span>
<span class="sd">            - history_source  : int [optional] - number of samples in the</span>
<span class="sd">              source&#39;s past used as embedding (default=same as the target</span>
<span class="sd">              history). (&gt;= 1)</span>
<span class="sd">            - tau_source : int [optional] - source&#39;s embedding delay</span>
<span class="sd">              (default=1). (&gt;= 1)</span>
<span class="sd">            - tau_target : int [optional] - target&#39;s embedding delay</span>
<span class="sd">              (default=1). (&gt;= 1)</span>
<span class="sd">            - source_target_delay : int [optional] - information transfer delay</span>
<span class="sd">              between source and target (default=1) (&gt;= 0)</span>
<span class="sd">            - discretise_method : str [optional] - if and how to discretise</span>
<span class="sd">              incoming continuous data, can be &#39;max_ent&#39; for maximum entropy</span>
<span class="sd">              binning, &#39;equal&#39; for equal size bins, and &#39;none&#39; if no binning is</span>
<span class="sd">              required (default=&#39;none&#39;)</span>
<span class="sd">            - n_discrete_bins : int [optional] - number of discrete bins/</span>
<span class="sd">              levels or the base of each dimension of the discrete variables</span>
<span class="sd">              (default=2). If set, this parameter overwrites/sets alph1 and</span>
<span class="sd">              alph2. (&gt;= 2)</span>
<span class="sd">            - alph1 : int [optional] - number of discrete bins/levels for</span>
<span class="sd">              source (default=2, or the value set for n_discrete_bins). (&gt;= 2)</span>
<span class="sd">            - alph2 : int [optional] - number of discrete bins/levels for</span>
<span class="sd">              target (default=2, or the value set for n_discrete_bins). (&gt;= 2)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Get embedding and delay parameters.</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_te_defaults</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Get alphabet sizes and check if discretisation is requested. Try to</span>
        <span class="c1"># overwrite alphabet sizes with number of bins.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n_discrete_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_discrete_bins&#39;</span><span class="p">])</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_discrete_bins</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># do nothing and set alphabet sizes to default below</span>
            <span class="k">pass</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph1&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alph2&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Num discrete levels for source has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Num discrete levels for target has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Num discrete levels for source must be &gt;= 2&#39;</span>
        <span class="k">assert</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Num discrete levels for target must be &gt;= 2&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.discrete&#39;</span><span class="p">)</span><span class="o">.</span>
                          <span class="n">TransferEntropyCalculatorDiscrete</span><span class="p">)</span>

<div class="viewcode-block" id="JidtDiscreteTE.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteTE.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">return_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate transfer entropy from a source to a target variable.</span>

<span class="sd">        Args:</span>
<span class="sd">            source : numpy array</span>
<span class="sd">                realisations of source variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            target : numpy array</span>
<span class="sd">                realisations of target variable (similar to var1)</span>
<span class="sd">            return_calc : boolean</span>
<span class="sd">                return the calculator used here as well as the numeric</span>
<span class="sd">                calculated value(s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average TE over all samples or local TE for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here. Only returned if</span>
<span class="sd">                return_calc was set.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ex.JidtOutOfMemoryError</span>
<span class="sd">                Raised when JIDT object cannot be instantiated due to mem error</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Discretise variables if requested.</span>
        <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretise_vars</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

        <span class="c1"># And finally make the TE calculation:</span>
        <span class="n">max_base</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph1&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alph2&#39;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CalcClass</span><span class="p">(</span><span class="n">max_base</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_target&#39;</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_source&#39;</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">jp</span><span class="o">.</span><span class="n">JavaException</span><span class="p">:</span>
            <span class="c1"># Only possible exception that can be raised here</span>
            <span class="c1">#  (if max_base &gt;= 2) is a Java OutOfMemoryException:</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">max_base</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ex</span><span class="o">.</span><span class="n">JidtOutOfMemoryError</span><span class="p">(</span><span class="s1">&#39;Cannot instantiate JIDT TE &#39;</span>
                <span class="s1">&#39;discrete estimator with max_base = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_base</span><span class="p">)</span> <span class="o">+</span>
                 <span class="s1">&#39; and history_target = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">])</span> <span class="o">+</span>
                 <span class="s1">&#39; and history_source = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">])</span> <span class="o">+</span>
                 <span class="s1">&#39;. Try re-running increasing Java heap size&#39;</span><span class="p">)</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">()</span>
        <span class="c1"># Unfortunately no faster way to pass numpy arrays in than this list</span>
        <span class="c1"># conversion</span>
        <span class="n">calc</span><span class="o">.</span><span class="n">addObservations</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">source</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                             <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">target</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalFromPreviousObservations</span><span class="p">(</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">source</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                <span class="n">jp</span><span class="o">.</span><span class="n">JArray</span><span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JInt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)(</span><span class="n">target</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_calc</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">calc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="JidtDiscreteTE.get_analytic_distribution"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_analytic_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a JIDT AnalyticNullDistribution object.</span>

<span class="sd">        Required so that our estimate_surrogates_analytic method can use the</span>
<span class="sd">        common_estimate_surrogates_analytic() method, where data is formatted</span>
<span class="sd">        as per the estimate method for this estimator.</span>

<span class="sd">        Args:</span>
<span class="sd">            source : numpy array</span>
<span class="sd">                realisations of source variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations], array type can be</span>
<span class="sd">                float (requires discretisation) or int</span>
<span class="sd">            target : numpy array</span>
<span class="sd">                realisations of target variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Java object</span>
<span class="sd">                JIDT calculator that was used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make one estimate to prepare the calculator:</span>
        <span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">jidt_calc</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jidt_calc</span><span class="o">.</span><span class="n">computeSignificance</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="JidtGaussianTE"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianTE">[docs]</a><span class="k">class</span> <span class="nc">JidtGaussianTE</span><span class="p">(</span><span class="n">JidtGaussian</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate transfer entropy with JIDT&#39;s Gaussian implementation.</span>

<span class="sd">    Calculate transfer entropy between a source and a target variable using</span>
<span class="sd">    JIDT&#39;s implementation of the Gaussian estimator. Transfer entropy is</span>
<span class="sd">    defined as the conditional mutual information between the source&#39;s past</span>
<span class="sd">    state and the target&#39;s current value, conditional on the target&#39;s past.</span>

<span class="sd">    Past states need to be defined in the settings dictionary, where a past</span>
<span class="sd">    state is defined as a uniform embedding with parameters history and tau.</span>
<span class="sd">    The history describes the number of samples taken from a variable&#39;s past,</span>
<span class="sd">    tau descrices the embedding delay, i.e., the spacing between every two</span>
<span class="sd">    samples from the processes&#39; past.</span>

<span class="sd">    See parent class for references.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            sets estimation parameters:</span>

<span class="sd">            - history_target : int - number of samples in the target&#39;s past</span>
<span class="sd">              used as embedding</span>
<span class="sd">            - history_source  : int [optional] - number of samples in the</span>
<span class="sd">              source&#39;s past used as embedding (default=same as the target</span>
<span class="sd">              history)</span>
<span class="sd">            - tau_source : int [optional] - source&#39;s embedding delay</span>
<span class="sd">              (default=1)</span>
<span class="sd">            - tau_target : int [optional] - target&#39;s embedding delay</span>
<span class="sd">              (default=1)</span>
<span class="sd">            - source_target_delay : int [optional] - information transfer delay</span>
<span class="sd">              between source and target (default=1)</span>
<span class="sd">            - debug : bool [optional] - return debug information when calling</span>
<span class="sd">              JIDT (default=False)</span>
<span class="sd">            - local_values : bool [optional] - return local TE instead of</span>
<span class="sd">              average TE (default=False)</span>

<span class="sd">    Note:</span>
<span class="sd">        Some technical details: JIDT normalises over realisations, IDTxl</span>
<span class="sd">        normalises over raw data once, outside the CMI estimator to save</span>
<span class="sd">        computation time. The Theiler window ignores trial boundaries. The</span>
<span class="sd">        CMI estimator does add noise to the data as a default. To make analysis</span>
<span class="sd">        runs replicable set noise_level to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_settings</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Start JAVA virtual machine and create JAVA object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start_jvm</span><span class="p">()</span>
        <span class="n">CalcClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">jp</span><span class="o">.</span><span class="n">JPackage</span><span class="p">(</span><span class="s1">&#39;infodynamics.measures.continuous.gaussian&#39;</span><span class="p">)</span><span class="o">.</span>
                     <span class="n">TransferEntropyCalculatorGaussian</span><span class="p">)</span>
        <span class="c1"># Get embedding and delay parameters.</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_te_defaults</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">CalcClass</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>

<div class="viewcode-block" id="JidtGaussianTE.estimate"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.JidtGaussianTE.estimate">[docs]</a>    <span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate transfer entropy from a source to a target variable.</span>

<span class="sd">        Args:</span>
<span class="sd">            source : numpy array</span>
<span class="sd">                realisations of source variable, either a 2D numpy array where</span>
<span class="sd">                array dimensions represent [realisations x variable dimension]</span>
<span class="sd">                or a 1D array representing [realisations]</span>
<span class="sd">            var2 : numpy array</span>
<span class="sd">                realisations of target variable (similar to var1)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float | numpy array</span>
<span class="sd">                average TE over all samples or local TE for individual</span>
<span class="sd">                samples if &#39;local_values&#39;=True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_one_dim_input</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">initialise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_target&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_target&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;history_source&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;tau_source&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;source_target_delay&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">setObservations</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;local_values&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeLocalOfPreviousObservations</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc</span><span class="o">.</span><span class="n">computeAverageLocalOfObservations</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="common_estimate_surrogates_analytic"><a class="viewcode-back" href="../../idtxl_estimators.html#idtxl.estimators_jidt.common_estimate_surrogates_analytic">[docs]</a><span class="k">def</span> <span class="nf">common_estimate_surrogates_analytic</span><span class="p">(</span><span class="n">estimator</span><span class="p">,</span> <span class="n">n_perm</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the surrogate distribution analytically for JidtEstimator.</span>

<span class="sd">    Estimate the surrogate distribution analytically for a JidtEstimator</span>
<span class="sd">    which is_analytic_null_estimator(), by sampling estimates at random</span>
<span class="sd">    p-values in the analytic distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        estimator : a JidtEstimator object, which returns True to a call to</span>
<span class="sd">            its is_analytic_null_estimator() method</span>
<span class="sd">        n_perms : int</span>
<span class="sd">            number of permutations (default=200)</span>
<span class="sd">        data : numpy arrays</span>
<span class="sd">            realisations of random variables required for the calculation</span>
<span class="sd">            (varies between estimators, e.g. 2 variables for MI, 3 for CMI)</span>

<span class="sd">    Returns:</span>
<span class="sd">        float | numpy array</span>
<span class="sd">            n_perm surrogates of the average MI/CMI/TE over all samples</span>
<span class="sd">            under the null hypothesis of no relationship between var1 and</span>
<span class="sd">            var2 (in the context of conditional)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute the statistical significance of the estimate to get an</span>
    <span class="c1">#  AnalyticMeasurementDistribution object:</span>
    <span class="n">analytic_distribution</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">get_analytic_distribution</span><span class="p">(</span><span class="o">**</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># Then compute surrogates at n_perm random p-values</span>
    <span class="n">surrogate_estimates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="n">surrogate_estimates</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">analytic_distribution</span><span class="o">.</span><span class="n">computeEstimateForGivenPValue</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">surrogate_estimates</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>