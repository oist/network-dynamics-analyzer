
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>idtxl.results &#8212; IDTxl 1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for idtxl.results</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Provide results class for IDTxl network analysis.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">idtxl_utils</span> <span class="k">as</span> <span class="n">utils</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
<span class="n">MIN_INT</span> <span class="o">=</span> <span class="o">-</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># minimum integer for initializing adj. matrix</span>


<div class="viewcode-block" id="DotDict"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.DotDict">[docs]</a><span class="k">class</span> <span class="nc">DotDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dictionary with dot-notation access to values.</span>

<span class="sd">    Provides the same functionality as a regular dict, but also allows</span>
<span class="sd">    accessing values using dot-notation.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; from idtxl.results import DotDict</span>
<span class="sd">        &gt;&gt;&gt; d = DotDict({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">        &gt;&gt;&gt; d.a</span>
<span class="sd">        &gt;&gt;&gt; # Out: 1</span>
<span class="sd">        &gt;&gt;&gt; d[&#39;a&#39;]</span>
<span class="sd">        &gt;&gt;&gt; # Out: 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">get</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span>
    <span class="fm">__delattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dictionary keys as list of attributes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide deep copy capabilities.</span>

<span class="sd">        Following a fix described here:</span>
<span class="sd">        https://github.com/aparo/pyes/pull/115/commits/d2076b385c38d6d00cebfe0df7b0d1ba8df934bc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dot_dict_copy</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">([</span>
            <span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">memo</span><span class="p">),</span>
             <span class="n">cp</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">dot_dict_copy</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For pickling the object</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># For un-pickling the object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span></div>
        <span class="c1"># self.__dict__ = self</span>


<div class="viewcode-block" id="AdjacencyMatrix"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix">[docs]</a><span class="k">class</span> <span class="nc">AdjacencyMatrix</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Adjacency matrix representing inferred networks.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">weight_type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">weight_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">weight_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weight_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">weight_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weight_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span>
        <span class="k">elif</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weight_type</span> <span class="o">=</span> <span class="n">weight_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown weight data type </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">weight_type</span><span class="p">))</span>

<div class="viewcode-block" id="AdjacencyMatrix.n_nodes"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.n_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">n_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AdjacencyMatrix.n_edges"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.n_edges">[docs]</a>    <span class="k">def</span> <span class="nf">n_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="AdjacencyMatrix.add_edge"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add weighted edge (i, j) to adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Can not add weight of type </span><span class="si">{0}</span><span class="s1"> to adjacency matrix of type &#39;</span>
                <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">weight</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight_type</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span></div>

<div class="viewcode-block" id="AdjacencyMatrix.add_edge_list"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.add_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_list</span><span class="p">,</span> <span class="n">j_list</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add multiple weighted edges (i, j) to adjacency matrix.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">j_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;Lists with edge indices must be of same length.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;Edge weights must have same length as edge indices.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i_list</span><span class="p">,</span> <span class="n">j_list</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdjacencyMatrix.print_matrix"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.print_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">print_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print weight and edge matrix.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weight_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="AdjacencyMatrix.get_edge_list"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.AdjacencyMatrix.get_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of weighted edges.</span>

<span class="sd">        Returns</span>
<span class="sd">            list of tuples</span>
<span class="sd">                each entry represents one edge in the graph: (i, j, weight)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>  <span class="c1"># list of tuples</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">()):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="n">edge_list</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">edge_list</span></div></div>


<div class="viewcode-block" id="Results"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.Results">[docs]</a><span class="k">class</span> <span class="nc">Results</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Parent class for results of network analysis algorithms.</span>

<span class="sd">    Provide a container for results of network analysis algorithms, e.g.,</span>
<span class="sd">    MultivariateTE or ActiveInformationStorage.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for estimation of information theoretic measures and</span>
<span class="sd">            statistical testing</span>
<span class="sd">        data_properties : dict</span>
<span class="sd">            data properties, contains</span>

<span class="sd">                - n_nodes : int - total number of nodes in the network</span>
<span class="sd">                - n_realisations : int - number of samples available for</span>
<span class="sd">                  analysis given the settings (e.g., a high maximum lag used in</span>
<span class="sd">                  network inference, results in fewer data points available for</span>
<span class="sd">                  estimation)</span>
<span class="sd">                - normalised : bool - indicates if data were z-standardised</span>
<span class="sd">                  before the estimation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">({})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">({</span>
            <span class="s1">&#39;n_nodes&#39;</span><span class="p">:</span> <span class="n">n_nodes</span><span class="p">,</span>
            <span class="s1">&#39;n_realisations&#39;</span><span class="p">:</span> <span class="n">n_realisations</span><span class="p">,</span>
            <span class="s1">&#39;normalised&#39;</span><span class="p">:</span> <span class="n">normalised</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">_print_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print edge list to console.&quot;&quot;&quot;</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">get_edge_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">edge_list</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">: </span><span class="si">{3}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No significant links found in the network.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="c1"># Check if new result process is part of the network</span>
        <span class="k">if</span> <span class="n">process</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Can not add single result - process </span><span class="si">{0}</span><span class="s1"> is not&#39;</span>
                               <span class="s1">&#39; in no. nodes in the data (</span><span class="si">{1}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                   <span class="n">process</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">))</span>
        <span class="c1"># Don&#39;t add duplicate processes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_duplicate_process</span><span class="p">(</span><span class="n">process</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Can not add single result - results for target&#39;</span>
                               <span class="s1">&#39; or process </span><span class="si">{0}</span><span class="s1"> already exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                   <span class="n">process</span><span class="p">))</span>
        <span class="c1"># Don&#39;t add results with conflicting settings</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">conflicting_entries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s1">&#39;Can not add single result - analysis settings are not equal.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_duplicate_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
        <span class="c1"># Test if process is already present in object</span>
        <span class="k">if</span> <span class="n">process</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processes_analysed</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Results.combine_results"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.Results.combine_results">[docs]</a>    <span class="k">def</span> <span class="nf">combine_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine multiple (partial) results objects.</span>

<span class="sd">        Combine a list of partial network analysis results into a single</span>
<span class="sd">        results object (e.g., results from analysis parallelized over</span>
<span class="sd">        processes). Raise an error if duplicate processes occur in partial</span>
<span class="sd">        results, or if analysis settings are not equal.</span>

<span class="sd">        Note that only conflicting settings cause an error (i.e., settings with</span>
<span class="sd">        equal keys but different values). If additional settings are included</span>
<span class="sd">        in partial results (i.e., settings with different keys) these settings</span>
<span class="sd">        are added to the common settings dictionary.</span>

<span class="sd">        Remove FDR-corrections from partial results before combining them. FDR-</span>
<span class="sd">        correction performed on the basis of parts of the network is not valid</span>
<span class="sd">        for the combined network.</span>

<span class="sd">        Args:</span>
<span class="sd">            results : list of Results objects</span>
<span class="sd">                single process analysis results from .analyse_network or</span>
<span class="sd">                .analyse_single_process methods, where each object contains</span>
<span class="sd">                partial results for one or multiple processes</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                combined results object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">processes</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">_processes_analysed</span>
            <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">conflicting_entries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">settings</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Can not combine results - analysis &#39;</span>
                                   <span class="s1">&#39;settings are not equal.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">processes</span><span class="p">:</span>
                <span class="c1"># Remove potential partial FDR-corrected results. These are no</span>
                <span class="c1"># longer valid for the combined network.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_duplicate_process</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Can not combine results - results for &#39;</span>
                                       <span class="s1">&#39;process </span><span class="si">{0}</span><span class="s1"> already exist.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">r</span><span class="o">.</span><span class="n">fdr_corrected</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Removing FDR-corrected results.&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">results_to_add</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">results_to_add</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">_single_process</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                            <span class="s1">&#39;Did not find any method attributes to combine &#39;</span>
                            <span class="s1">&#39;(.single_proces or ._single_target).&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_single_result</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">results_to_add</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ResultsSingleProcessAnalysis"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsSingleProcessAnalysis">[docs]</a><span class="k">class</span> <span class="nc">ResultsSingleProcessAnalysis</span><span class="p">(</span><span class="n">Results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store results of single process analysis.</span>

<span class="sd">    Provide a container for the results of algorithms for the analysis of</span>
<span class="sd">    individual processes (nodes) in a multivariate stochastic process,</span>
<span class="sd">    e.g., estimation of active information storage.</span>

<span class="sd">    Note that for convenience all dictionaries in this class can additionally</span>
<span class="sd">    be accessed using dot-notation:</span>

<span class="sd">    &gt;&gt;&gt; res_network.settings.cmi_estimator</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; res_network.settings[&#39;cmi_estimator&#39;].</span>

<span class="sd">    Attributes:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for estimation of information theoretic measures and</span>
<span class="sd">            statistical testing</span>
<span class="sd">        data_properties : dict</span>
<span class="sd">            data properties, contains</span>

<span class="sd">                - n_nodes : int - total number of nodes in the network</span>
<span class="sd">                - n_realisations : int - number of samples available for</span>
<span class="sd">                  analysis given the settings (e.g., a high maximum lag used in</span>
<span class="sd">                  network inference, results in fewer data points available for</span>
<span class="sd">                  estimation)</span>
<span class="sd">                - normalised : bool - indicates if data were z-standardised</span>
<span class="sd">                  before estimation</span>

<span class="sd">        processes_analysed : list</span>
<span class="sd">            list of analysed processes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes_analysed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_process</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_process_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">processes_analysed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get index of the current_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processes_analysed</span>

    <span class="nd">@processes_analysed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">processes_analysed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processes_analysed</span> <span class="o">=</span> <span class="n">processes</span>

    <span class="k">def</span> <span class="nf">_add_single_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add analysis result for a single process.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_result</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">DotDict</span><span class="p">(</span><span class="n">settings</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_process</span><span class="p">[</span><span class="n">process</span><span class="p">]</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">processes_analysed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_single_process</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_add_fdr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdr</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add settings and results of FDR correction.&quot;&quot;&quot;</span>
        <span class="c1"># Add settings of FDR-correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_fdr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fdr_constant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="c1"># Add results of FDR-correction. FDR-correction can be None if</span>
        <span class="c1"># correction is impossible due to the number of permutations in</span>
        <span class="c1"># individual analysis being too low to allow for individual p-values</span>
        <span class="c1"># to reach the FDR-thresholds. Add empty results in that case.</span>
        <span class="k">if</span> <span class="n">fdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_single_process_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_single_process_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">fdr</span><span class="p">)</span>

<div class="viewcode-block" id="ResultsSingleProcessAnalysis.get_single_process"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsSingleProcessAnalysis.get_single_process">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">process</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return results for a single process in the network.</span>

<span class="sd">        Return results for individual processes, contains for each process</span>

<span class="sd">            - ais : float - AIS-value for current process</span>
<span class="sd">            - ais_pval : float - p-value of AIS estimate</span>
<span class="sd">            - ais_sign : bool - significance of AIS estimate wrt. to the</span>
<span class="sd">                alpha_mi specified in the settings</span>
<span class="sd">            - selected_var : list of tuples - variables with significant</span>
<span class="sd">                information about the current value of the process that have</span>
<span class="sd">                been added to the processes past state, a variable is</span>
<span class="sd">                described by the index of the process in the data and its lag</span>
<span class="sd">                in samples</span>
<span class="sd">            - current_value : tuple - current value used for analysis,</span>
<span class="sd">                described by target and sample index in the data</span>

<span class="sd">        Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</span>

<span class="sd">        Args:</span>
<span class="sd">            process : int</span>
<span class="sd">                process id</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results, see documentation of network</span>
<span class="sd">                inference algorithms and stats.network_fdr (default=True)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                results for single process. Note that for convenience</span>
<span class="sd">                dictionary entries can either be accessed via keywords</span>
<span class="sd">                (result[&#39;selected_vars&#39;]) or via dot-notation</span>
<span class="sd">                (result.selected_vars).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return required key from required _single_process dictionary, dealing</span>
        <span class="c1"># with the FDR at a high level</span>
        <span class="k">if</span> <span class="n">process</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes_analysed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No results for process </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">process</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fdr</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_process_fdr</span><span class="p">[</span><span class="n">process</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No FDR-corrected results have been added. Set&#39;</span>
                    <span class="s1">&#39; &#39;&#39;fdr=False&#39;&#39; to see uncorrected results.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No FDR-corrected results for process </span><span class="si">{0}</span><span class="s1">. Set&#39;</span>
                    <span class="s1">&#39; &#39;&#39;fdr=False&#39;&#39; to see uncorrected results.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">process</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_process</span><span class="p">[</span><span class="n">process</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No results have been added.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No results for process </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">process</span><span class="p">))</span></div>

<div class="viewcode-block" id="ResultsSingleProcessAnalysis.get_significant_processes"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsSingleProcessAnalysis.get_significant_processes">[docs]</a>    <span class="k">def</span> <span class="nf">get_significant_processes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return statistically-significant processes.</span>

<span class="sd">        Indicates for each process whether AIS is statistically significant</span>
<span class="sd">        (equivalent to the adjacency matrix returned for network inference)</span>

<span class="sd">        Args:</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results, see documentation of network</span>
<span class="sd">                inference algorithms and stats.network_fdr (default=True)</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy array</span>
<span class="sd">                Statistical significance for each process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">significant_processes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_single_process</span><span class="p">(</span><span class="n">process</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)[</span><span class="s1">&#39;ais_sign&#39;</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processes_analysed</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">significant_processes</span></div></div>


<div class="viewcode-block" id="ResultsNetworkAnalysis"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.ResultsNetworkAnalysis">[docs]</a><span class="k">class</span> <span class="nc">ResultsNetworkAnalysis</span><span class="p">(</span><span class="n">Results</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">targets_analysed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get index of the current_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processes_analysed</span>

    <span class="nd">@targets_analysed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">targets_analysed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processes_analysed</span> <span class="o">=</span> <span class="n">targets</span>

    <span class="k">def</span> <span class="nf">_add_single_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add analysis result for a single target.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_result</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
        <span class="c1"># Add results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">DotDict</span><span class="p">(</span><span class="n">settings</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="ResultsNetworkAnalysis.get_single_target"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.ResultsNetworkAnalysis.get_single_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return results for a single target in the network.</span>

<span class="sd">        Return results for individual processes, contains for each process</span>

<span class="sd">        Results for single targets include for each target</span>

<span class="sd">        - omnibus_te : float - TE-value for joint information transfer from all</span>
<span class="sd">          sources into the target</span>
<span class="sd">        - omnibus_pval : float - p-value of omnibus information transfer into</span>
<span class="sd">          the target</span>
<span class="sd">        - omnibus_sign : bool - significance of omnibus information transfer</span>
<span class="sd">          wrt. to the alpha_omnibus specified in the settings</span>
<span class="sd">        - selected_vars_sources : list of tuples - source variables with</span>
<span class="sd">          significant information about the current value</span>
<span class="sd">        - selected_vars_target : list of tuples - target variables with</span>
<span class="sd">          significant information about the current value</span>
<span class="sd">        - selected_sources_pval : array of floats - p-value for each selected</span>
<span class="sd">          variable</span>
<span class="sd">        - selected_sources_te : array of floats - TE-value for each selected</span>
<span class="sd">          variable</span>
<span class="sd">        - sources_tested : list of int - list of sources tested for the current</span>
<span class="sd">          target</span>
<span class="sd">        - current_value : tuple - current value used for analysis, described by</span>
<span class="sd">          target and sample index in the data</span>

<span class="sd">        Setting fdr to True returns FDR-corrected results (Benjamini, 1995).</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target id</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results, see documentation of network</span>
<span class="sd">                inference algorithms and stats.network_fdr (default=True)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                Results for single target. Note that for convenience</span>
<span class="sd">                dictionary entries can either be accessed via keywords</span>
<span class="sd">                (result[&#39;selected_vars_sources&#39;]) or via dot-notation</span>
<span class="sd">                (result.selected_vars_sources).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No results for target </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fdr</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target_fdr</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No FDR-corrected results have been added. Set&#39;</span>
                    <span class="s1">&#39; &#39;&#39;fdr=False&#39;&#39; to see uncorrected results.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No FDR-corrected results for target </span><span class="si">{0}</span><span class="s1">. Set&#39;</span>
                    <span class="s1">&#39; &#39;&#39;fdr=False&#39;&#39; to see uncorrected results.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">target</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;No results have been added.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;No results for target </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">))</span></div>

<div class="viewcode-block" id="ResultsNetworkAnalysis.get_target_sources"><a class="viewcode-back" href="../../idtxl.html#idtxl.results.ResultsNetworkAnalysis.get_target_sources">[docs]</a>    <span class="k">def</span> <span class="nf">get_target_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of sources (parents) for given target.</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target index</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                if True, sources are returned for FDR-corrected results</span>
<span class="sd">                (default=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="p">)[</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span></div></div>


<div class="viewcode-block" id="ResultsNetworkInference"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkInference">[docs]</a><span class="k">class</span> <span class="nc">ResultsNetworkInference</span><span class="p">(</span><span class="n">ResultsNetworkAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store results of network inference.</span>

<span class="sd">    Provide a container for results of network inference algorithms, e.g.,</span>
<span class="sd">    MultivariateTE or Bivariate TE.</span>

<span class="sd">    Note that for convenience all dictionaries in this class can additionally</span>
<span class="sd">    be accessed using dot-notation:</span>

<span class="sd">    &gt;&gt;&gt; res_network.settings.cmi_estimator</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; res_network.settings[&#39;cmi_estimator&#39;].</span>

<span class="sd">    Attributes:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for estimation of information theoretic measures and</span>
<span class="sd">            statistical testing</span>
<span class="sd">        data_properties : dict</span>
<span class="sd">            data properties, contains</span>

<span class="sd">                - n_nodes : int - total number of nodes in the network</span>
<span class="sd">                - n_realisations : int - number of samples available for</span>
<span class="sd">                  analysis given the settings (e.g., a high maximum lag used in</span>
<span class="sd">                  network inference, results in fewer data points available for</span>
<span class="sd">                  estimation)</span>
<span class="sd">                - normalised : bool - indicates if data were z-standardised</span>
<span class="sd">                  before estimation</span>

<span class="sd">        targets_analysed : list</span>
<span class="sd">            list of analysed targets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_target_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_add_fdr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdr</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">correct_by_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add settings and results of FDR correction.&quot;&quot;&quot;</span>
        <span class="c1"># Add settings of FDR-correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_fdr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fdr_correct_by_target&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_by_target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fdr_constant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">constant</span>
        <span class="c1"># Add results of FDR-correction. FDR-correction can be None if</span>
        <span class="c1"># correction is impossible due to the number of permutations in</span>
        <span class="c1"># individual analysis being too low to allow for individual p-values</span>
        <span class="c1"># to reach the FDR-thresholds. Add empty results in that case.</span>
        <span class="k">if</span> <span class="n">fdr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_single_target_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_single_target_fdr</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">fdr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_inference_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;selected_sources_te&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_te</span>
        <span class="k">elif</span> <span class="s1">&#39;selected_sources_mi&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">selected_sources_mi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;No entry with network inference measure found for &#39;</span>
                           <span class="s1">&#39;current target&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ResultsNetworkInference.get_target_delays"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkInference.get_target_delays">[docs]</a>    <span class="k">def</span> <span class="nf">get_target_delays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;max_te&#39;</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of information-transfer delays for a given target.</span>

<span class="sd">        Return a list of information-transfer delays for a given target.</span>
<span class="sd">        Information-transfer delays are determined by the lag of the variable</span>
<span class="sd">        in a source past that has the highest information transfer into the</span>
<span class="sd">        target process. There are two ways of identifying the variable with</span>
<span class="sd">        maximum information transfer:</span>

<span class="sd">            a) use the variable with the highest absolute TE value (highest</span>
<span class="sd">               information transfer),</span>
<span class="sd">            b) use the variable with the smallest p-value (highest statistical</span>
<span class="sd">               significance).</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target index</span>
<span class="sd">            criterion : str [optional]</span>
<span class="sd">                use maximum TE value (&#39;max_te&#39;) or p-value (&#39;max_p&#39;) to</span>
<span class="sd">                determine the source-target delay (default=&#39;max_te&#39;)</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results (default=True)</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy array</span>
<span class="sd">                information-transfer delays for each source</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Get the source index for each past source variable of the target</span>
        <span class="n">all_vars_sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)[</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]])</span>
        <span class="c1"># Get the lag for each past source variable of the target</span>
        <span class="n">all_vars_lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)[</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]])</span>
        <span class="c1"># Get p-values and TE-values for past source variable</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)[</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">]</span>
        <span class="n">measure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_inference_measure</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Find delay for each source</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;max_p&#39;</span><span class="p">:</span>
                <span class="c1"># Find the minimum p-value amongst the variables in source s</span>
                <span class="n">delays_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">pval</span><span class="p">[</span><span class="n">all_vars_sources</span> <span class="o">==</span> <span class="n">s</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;max_te&#39;</span><span class="p">:</span>
                <span class="c1"># Find the maximum TE-value amongst the variables in source s</span>
                <span class="n">delays_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">measure</span><span class="p">[</span><span class="n">all_vars_sources</span> <span class="o">==</span> <span class="n">s</span><span class="p">])</span>

            <span class="n">delays</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_vars_lags</span><span class="p">[</span><span class="n">all_vars_sources</span> <span class="o">==</span> <span class="n">s</span><span class="p">][</span><span class="n">delays_ind</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">delays</span></div>

<div class="viewcode-block" id="ResultsNetworkInference.get_adjacency_matrix"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkInference.get_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return adjacency matrix.</span>

<span class="sd">        Return adjacency matrix resulting from network inference. The adjacency</span>
<span class="sd">        matrix can either be generated from FDR-corrected results or</span>
<span class="sd">        uncorrected results. Multiple options for the weight are available.</span>

<span class="sd">        Args:</span>
<span class="sd">            weights : str</span>
<span class="sd">                can either be</span>

<span class="sd">                - &#39;max_te_lag&#39;: the weights represent the source -&gt; target</span>
<span class="sd">                   lag corresponding to the maximum tranfer entropy value</span>
<span class="sd">                   (see documentation for method get_target_delays for details)</span>
<span class="sd">                - &#39;max_p_lag&#39;: the weights represent the source -&gt; target</span>
<span class="sd">                   lag corresponding to the maximum p-value</span>
<span class="sd">                   (see documentation for method get_target_delays for details)</span>
<span class="sd">                - &#39;vars_count&#39;: the weights represent the number of</span>
<span class="sd">                   statistically-significant source -&gt; target lags</span>
<span class="sd">                - &#39;binary&#39;: return unweighted adjacency matrix with binary</span>
<span class="sd">                   entries</span>

<span class="sd">                   - 1 = significant information transfer;</span>
<span class="sd">                   - 0 = no significant information transfer.</span>

<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results (default=True)</span>

<span class="sd">        Returns:</span>
<span class="sd">            AdjacencyMatrix instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">AdjacencyMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;max_te_lag&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_delays</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                                <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;max_te&#39;</span><span class="p">,</span>
                                                <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">delays</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;max_p_lag&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_delays</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                                                <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;max_p&#39;</span><span class="p">,</span>
                                                <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">delays</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;vars_count&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">single_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">):</span>
                    <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">single_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">single_result</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">):</span>
                    <span class="n">sources</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid weights value&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adjacency_matrix</span></div>

<div class="viewcode-block" id="ResultsNetworkInference.print_edge_list"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkInference.print_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">print_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print results of network inference to console.</span>

<span class="sd">        Print edge list resulting from network inference to console.</span>
<span class="sd">        Output may look like this:</span>

<span class="sd">            &gt;&gt;&gt; 0 -&gt; 1, max_te_lag = 2</span>
<span class="sd">            &gt;&gt;&gt; 0 -&gt; 2, max_te_lag = 3</span>
<span class="sd">            &gt;&gt;&gt; 0 -&gt; 3, max_te_lag = 2</span>
<span class="sd">            &gt;&gt;&gt; 3 -&gt; 4, max_te_lag = 1</span>
<span class="sd">            &gt;&gt;&gt; 4 -&gt; 3, max_te_lag = 1</span>

<span class="sd">        The edge list can either be generated from FDR-corrected results</span>
<span class="sd">        or uncorrected results. Multiple options for the weight</span>
<span class="sd">        are available (see documentation of method get_adjacency_matrix for</span>
<span class="sd">        details).</span>

<span class="sd">        Args:</span>
<span class="sd">            weights : str</span>
<span class="sd">                link weights (see documentation of method get_adjacency_matrix</span>
<span class="sd">                for details)</span>
<span class="sd">            fdr : bool [optional]</span>
<span class="sd">                return FDR-corrected results (default=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="n">fdr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_edge_list</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ResultsPartialInformationDecomposition"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsPartialInformationDecomposition">[docs]</a><span class="k">class</span> <span class="nc">ResultsPartialInformationDecomposition</span><span class="p">(</span><span class="n">ResultsNetworkAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store results of Partial Information Decomposition (PID) analysis.</span>

<span class="sd">    Provide a container for results of Partial Information Decomposition (PID)</span>
<span class="sd">    algorithms.</span>

<span class="sd">    Note that for convenience all dictionaries in this class can additionally</span>
<span class="sd">    be accessed using dot-notation:</span>

<span class="sd">    &gt;&gt;&gt; res_pid._single_target[2].source_1</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; res_pid._single_target[2].[&#39;source_1&#39;].</span>

<span class="sd">    Attributes:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for estimation of information theoretic measures and</span>
<span class="sd">            statistical testing</span>
<span class="sd">        data_properties : dict</span>
<span class="sd">            data properties, contains</span>

<span class="sd">                - n_nodes : int - total number of nodes in the network</span>
<span class="sd">                - n_realisations : int - number of samples available for</span>
<span class="sd">                  analysis given the settings (e.g., a high maximum lag used in</span>
<span class="sd">                  network inference, results in fewer data points available for</span>
<span class="sd">                  estimation)</span>
<span class="sd">                - normalised : bool - indicates if data were z-standardised</span>
<span class="sd">                  before the estimation</span>

<span class="sd">        targets_analysed : list</span>
<span class="sd">            list of analysed targets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">)</span>

<div class="viewcode-block" id="ResultsPartialInformationDecomposition.get_single_target"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsPartialInformationDecomposition.get_single_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return results for a single target in the network.</span>

<span class="sd">        Results for single targets include for each target</span>

<span class="sd">        - source_1 : tuple - source variable 1</span>
<span class="sd">        - source_2 : tuple - source variable 2</span>
<span class="sd">        - selected_vars_sources : list of tuples - source variables used in PID</span>
<span class="sd">          estimation</span>
<span class="sd">        - s1_unq : float - unique information in source 1</span>
<span class="sd">        - s2_unq : float - unique information in source 2</span>
<span class="sd">        - syn_s1_s2 : float - synergistic information in sources 1 and 2</span>
<span class="sd">        - shd_s1_s2 : float - shared information in sources 1 and 2</span>
<span class="sd">        - current_value : tuple - current value used for analysis, described by</span>
<span class="sd">          target and sample index in the data</span>
<span class="sd">        - [estimator-specific settings]</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target id</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                Results for single target. Note that for convenience</span>
<span class="sd">                dictionary entries can either be accessed via keywords</span>
<span class="sd">                (result[&#39;selected_vars_sources&#39;]) or via dot-notation</span>
<span class="sd">                (result.selected_vars_sources).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ResultsPartialInformationDecomposition</span><span class="p">,</span>
                     <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ResultsNetworkComparison"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkComparison">[docs]</a><span class="k">class</span> <span class="nc">ResultsNetworkComparison</span><span class="p">(</span><span class="n">ResultsNetworkAnalysis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store results of network comparison.</span>

<span class="sd">    Provide a container for results of network comparison algorithms.</span>

<span class="sd">    Note that for convenience all dictionaries in this class can additionally</span>
<span class="sd">    be accessed using dot-notation: res_network.settings.cmi_estimator</span>
<span class="sd">    or res_network.settings[&#39;cmi_estimator&#39;].</span>

<span class="sd">    Attributes:</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for estimation of information theoretic measures and</span>
<span class="sd">            statistical testing</span>

<span class="sd">        data_properties : dict</span>
<span class="sd">            data properties, contains</span>

<span class="sd">                - n_nodes : int - total number of nodes in the network</span>
<span class="sd">                - n_realisations : int - number of samples available for</span>
<span class="sd">                  analysis given the settings (e.g., a high maximum lag used in</span>
<span class="sd">                  network inference, results in fewer data points available for</span>
<span class="sd">                  estimation)</span>
<span class="sd">                - normalised : bool - indicates if data were z-standardised</span>
<span class="sd">                  before the estimation</span>

<span class="sd">        surrogate_distribution : dict</span>
<span class="sd">            for each target, surrogate distributions used for testing of each</span>
<span class="sd">            link into the target</span>
<span class="sd">        targets_analysed : list</span>
<span class="sd">            list of analysed targets</span>
<span class="sd">        ab : dict</span>
<span class="sd">            for each target, list of comparison results for all links into the</span>
<span class="sd">            target; True if link in condition A &gt; link in condition B</span>
<span class="sd">        pval : dict</span>
<span class="sd">            for each target, list of p-values for all compared links</span>
<span class="sd">        cmi_diff_abs : dict</span>
<span class="sd">            for each target, list of absolute difference in interaction measure</span>
<span class="sd">            for all compared links</span>
<span class="sd">        data_properties : dict</span>
<span class="sd">            information regarding the data used for analysis</span>
<span class="sd">        settings : dict</span>
<span class="sd">            settings used for comparison</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="n">n_realisations</span><span class="p">,</span> <span class="n">normalised</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">union_network</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="c1"># Check if results have already been added to this instance.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeWarning</span><span class="p">(</span><span class="s1">&#39;Overwriting existing results.&#39;</span><span class="p">)</span>
        <span class="c1"># Add results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span> <span class="o">=</span> <span class="n">union_network</span><span class="p">[</span><span class="s1">&#39;targets_analysed&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">DotDict</span><span class="p">(</span><span class="n">union_network</span><span class="o">.</span><span class="n">_single_target</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="c1"># self.max_lag = union_network[&#39;max_lag&#39;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surrogate_distributions</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cmi_surr&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ab</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;a&gt;b&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmi_diff_abs</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;cmi_diff_abs&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pval</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;pval&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="ResultsNetworkComparison.get_adjacency_matrix"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkComparison.get_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;comparison&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return adjacency matrix.</span>

<span class="sd">        Return adjacency matrix resulting from network inference.</span>
<span class="sd">        Multiple options for the weights are available.</span>

<span class="sd">        Args:</span>
<span class="sd">            weights : str [optional]</span>
<span class="sd">                can either be</span>

<span class="sd">                - &#39;union&#39;: all links in the union network, i.e., all</span>
<span class="sd">                  links that were tested for a difference</span>

<span class="sd">                or return information for links with a significant difference</span>

<span class="sd">                - &#39;comparison&#39;: True for links with a significant difference in</span>
<span class="sd">                   inferred effective connectivity (default)</span>
<span class="sd">                - &#39;pvalue&#39;: absolute differences in inferred effective</span>
<span class="sd">                   connectivity for significant links</span>
<span class="sd">                - &#39;diff_abs&#39;: absolute difference</span>

<span class="sd">        Returns:</span>
<span class="sd">            AdjacencyMatrix instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: right now, the network comparison work on the uncorrected</span>
        <span class="c1"># networks only. This may have to change in the future, in which case</span>
        <span class="c1"># the value for &#39;fdr&#39; when accessing single target results or adjacency</span>
        <span class="c1"># matrices has to be taken from the analysis settings.</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;comparison&#39;</span><span class="p">:</span>
            <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">AdjacencyMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
                    <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ab</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
            <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">AdjacencyMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span>
                    <span class="n">sources</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;diff_abs&#39;</span><span class="p">:</span>
            <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">AdjacencyMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmi_diff_abs</span><span class="p">)</span>
                    <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmi_diff_abs</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">weights</span> <span class="o">==</span> <span class="s1">&#39;pvalue&#39;</span><span class="p">:</span>
            <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="n">AdjacencyMatrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_properties</span><span class="o">.</span><span class="n">n_nodes</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">targets_analysed</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_sources</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
                    <span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pval</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid weights value&#39;</span><span class="p">)</span>

        <span class="c1"># self._print_edge_list(adjacency_matrix, weights=weights)</span>
        <span class="k">return</span> <span class="n">adjacency_matrix</span></div>

<div class="viewcode-block" id="ResultsNetworkComparison.print_edge_list"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkComparison.print_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">print_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;comparison&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print results of network comparison to console.</span>

<span class="sd">        Print results of network comparison to console. Output looks like this:</span>

<span class="sd">            &gt;&gt;&gt; 0 -&gt; 1, diff_abs = 0.2</span>
<span class="sd">            &gt;&gt;&gt; 0 -&gt; 2, diff_abs = 0.5</span>
<span class="sd">            &gt;&gt;&gt; 0 -&gt; 3, diff_abs = 0.7</span>
<span class="sd">            &gt;&gt;&gt; 3 -&gt; 4, diff_abs = 1.3</span>
<span class="sd">            &gt;&gt;&gt; 4 -&gt; 3, diff_abs = 0.4</span>

<span class="sd">        indicating differences in the network inference measure for a link</span>
<span class="sd">        source -&gt; target.</span>

<span class="sd">        Args:</span>
<span class="sd">            weights : str [optional]</span>
<span class="sd">                weights for the adjacency matrix (see documentation of method</span>
<span class="sd">                get_adjacency_matrix for details)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjacency_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_edge_list</span><span class="p">(</span><span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResultsNetworkComparison.get_single_target"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkComparison.get_single_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return results for a single target in the network.</span>

<span class="sd">        Results for single targets include for each target</span>

<span class="sd">        - sources : list of ints - list of sources inferred for the current</span>
<span class="sd">          target (union of sources from both data sets entering the comparison)</span>
<span class="sd">        - selected_vars_sources : list of tuples - source variables with</span>
<span class="sd">          significant information about the current value (union of both</span>
<span class="sd">          conditions)</span>
<span class="sd">        - selected_vars_target : list of tuples - target variables with</span>
<span class="sd">          significant information about the current value (union of both</span>
<span class="sd">          conditions)</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target id</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict</span>
<span class="sd">                Results for single target. Note that for convenience</span>
<span class="sd">                dictionary entries can either be accessed via keywords</span>
<span class="sd">                (result[&#39;selected_vars_sources&#39;]) or via dot-notation</span>
<span class="sd">                (result.selected_vars_sources).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ResultsNetworkComparison</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span>
            <span class="n">target</span><span class="p">,</span> <span class="n">fdr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResultsNetworkComparison.get_target_sources"><a class="viewcode-back" href="../../idtxl_results_class.html#idtxl.results.ResultsNetworkComparison.get_target_sources">[docs]</a>    <span class="k">def</span> <span class="nf">get_target_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of sources (parents) for given target.</span>

<span class="sd">        Args:</span>
<span class="sd">            target : int</span>
<span class="sd">                target index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_target</span><span class="p">(</span><span class="n">target</span><span class="p">)[</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">IDTxl 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Patricia Wollstadt, Joseph T. Lizier, Raul Vicente, Conor Finn, Mario Martinez-Zarzuela, Pedro Mediano, Leonardo Novelli, Michael Wibral.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>